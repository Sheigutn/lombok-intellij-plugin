package de.plushnikov.intellij.plugin.inspection.getter;

import com.intellij.codeInspection.*;
import com.intellij.codeInspection.redundantCast.RemoveRedundantCastUtil;
import com.intellij.openapi.project.Project;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import com.intellij.psi.util.RedundantCastUtil;
import de.plushnikov.intellij.plugin.thirdparty.LombokUtils;
import org.jetbrains.annotations.Nls;
import org.jetbrains.annotations.NotNull;

import java.util.Objects;

import static de.plushnikov.intellij.plugin.handler.LazyGetterHandler.isLazyGetterHandled;

public class LazyGetterFieldUsageInspection extends AbstractBaseJavaLocalInspectionTool {

  private static final String DESCRIPTION_TEMPLATE = "You should never refer to the field directly, always use the getter generated by Lombok, because the type of the field will be mangled into an AtomicReference. " +
    "Do not try to directly access this AtomicReference; if it points to itself, the value has been calculated, and it is null. " +
    "If the reference points to null, then the value has not been calculated. " +
    "This behaviour may change in future versions. " +
    "Therefore, always use the generated getter to access your field!";

  @NotNull
  @Override
  public PsiElementVisitor buildVisitor(@NotNull ProblemsHolder holder, boolean isOnTheFly) {
    return new LazyGetterFieldUsageVisitor(holder);
  }

  private static class LazyGetterFieldUsageVisitor extends JavaElementVisitor {

    private final ProblemsHolder holder;

    public LazyGetterFieldUsageVisitor(ProblemsHolder holder) {
      this.holder = holder;
    }

    @Override
    public void visitReferenceExpression(PsiReferenceExpression expression) {
      super.visitReferenceExpression(expression);

      PsiElement resolvedElement = expression.resolve();
      if (!(resolvedElement instanceof PsiField)) {
        return;
      }

      PsiField referencedField = (PsiField) resolvedElement;

      if (!isLazyGetterHandled(referencedField)) {
        return;
      }

      PsiMethodCallExpression methodCallExpression = PsiTreeUtil.getParentOfType(expression, PsiMethodCallExpression.class, false, PsiStatement.class);

      if (methodCallExpression != null) {
        PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();
        String methodName = Objects.requireNonNull(PsiTreeUtil.getChildOfType(methodExpression, PsiIdentifier.class)).getText();
        if (methodName.startsWith("get") && !("getClass".equals(methodName)) || methodName.contains("AndGet")) {
          holder.registerProblem(methodCallExpression, DESCRIPTION_TEMPLATE, ProblemHighlightType.ERROR,
            new ReplaceWithGetterCallQuickFix(methodCallExpression, referencedField));
          return;
        }
      }
      holder.registerProblem(expression, DESCRIPTION_TEMPLATE, ProblemHighlightType.ERROR);
    }
  }

  private static class ReplaceWithGetterCallQuickFix extends LocalQuickFixOnPsiElement {

    protected ReplaceWithGetterCallQuickFix(@NotNull PsiMethodCallExpression methodCallExpression, @NotNull PsiField referencedField) {
      super(methodCallExpression, referencedField);
    }

    @Nls(capitalization = Nls.Capitalization.Sentence)
    @NotNull
    @Override
    public String getText() {
      return "Replace with call to " + LombokUtils.getGetterName(getReferencedField()) + "()";
    }

    @Override
    public void invoke(@NotNull Project project, @NotNull PsiFile file, @NotNull PsiElement startElement, @NotNull PsiElement endElement) {
      PsiMethodCallExpression psiElement = (PsiMethodCallExpression) startElement;

      PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(project);
      PsiElement replace = psiElement.replace(
        elementFactory.createExpressionFromText(LombokUtils.getGetterName(getReferencedField()) + "()", psiElement)
      );

      if (replace.getParent() instanceof PsiTypeCastExpression) {
        PsiTypeCastExpression typeCastExpression = (PsiTypeCastExpression) replace.getParent();
        if (RedundantCastUtil.isCastRedundant(typeCastExpression)) {
          RemoveRedundantCastUtil.removeCast((PsiTypeCastExpression) replace.getParent());
        }
      }
    }

    @Nls(capitalization = Nls.Capitalization.Sentence)
    @NotNull
    @Override
    public String getFamilyName() {
      return "Replace with call to getter method";
    }

    @NotNull
    public PsiField getReferencedField() {
      return (PsiField) getEndElement();
    }
  }
}
